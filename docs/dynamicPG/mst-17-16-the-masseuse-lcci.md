# 面试题 17.16.按摩师
题目链接：[传送门](https://leetcode-cn.com/problems/the-masseuse-lcci/)

## 题目描述：
一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。

注意：本题相对原题稍作改动

**示例**：
- 输入：`[1,2,3,1]`
- 输出：`4`
- 解释：选择`1`号预约和`3`号预约，总时长 $ = 1 + 3 = 4 $。

## 解决方案：
- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$
- 思路：动态规划。定义`dp[i][0]`为第i个请求不处理（即不预约，且使得总预约时间最长），显然值为上一个预约请求的值与上一个不预约请求中两者间的最大值：`dp[i][0]=max(dp[i-1][0],d[i-1][1])`；`dp[i][1]`为第i个请求被处理（即预约请求），那么值只能取上一个不预约的值+当前预约请求的值（相邻不能预约）：`dp[i][1]=dp[i-1][0]+nums[i]`。

## AC代码：
```java
class Solution {
	public int massage(int[] nums) {
		int len;
		if (nums == null || (len = nums.length) == 0)
			return 0;
		int[][] dp = new int[len][2];
		dp[0][1] = nums[0];
		for (int i = 1; i < len; i++) {
			dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1]);
			dp[i][1] = dp[i - 1][0] + nums[i];
		}
		return Math.max(dp[len - 1][0], dp[len - 1][1]);
	}
}
```